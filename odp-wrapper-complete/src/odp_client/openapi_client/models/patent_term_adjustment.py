# coding: utf-8

"""
    Open Data Portal (ODP) API

    The Open Data Portal (ODP) API allows you to extract USPTO data at no cost - with several ways to do it. To learn about the ODP API Rate Limits, please visit to the <a href=\"https://data.uspto.gov/apis/api-rate-limits\" target=\"_blank\">API Rate Limits page</a>. <br><br> <b>Before proceeding</b>, you must have an ODP API key in order to access these Swagger UI resources. Once you have obtained an API key, you can pass the API key into a REST API call in the x-api-key header of the request. For more details and steps to generate an API key visit to the <a href=\"https://data.uspto.gov/apis/getting-started\" target=\"_blank\">Getting Started page</a>.<br><br>For example, the request to access patent data for an application might look like as below.<br><br><code>curl -X \"GET\" \"https://api.uspto.gov/api/v1/patent/applications/14412875\" -H \"X-API-KEY:YOUR_API_KEY\"</code><br><br></br><code>curl -X \"POST\" \"https://api.uspto.gov/api/v1/patent/applications/search\" -H \"X-API-KEY:YOUR_API_KEY\" -d \"{\\\\\"q\\\\\":\\\\\"applicationMetaData.applicationTypeLabelName:Utility\\\\\"}\"</br></code>

    The version of the OpenAPI document: 1.0.0
    Contact: data@uspto.gov
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.patent_term_adjustment_patent_term_adjustment_history_data_bag_inner import PatentTermAdjustmentPatentTermAdjustmentHistoryDataBagInner
from typing import Optional, Set
from typing_extensions import Self

class PatentTermAdjustment(BaseModel):
    """
    Patent term adjustment data
    """ # noqa: E501
    a_delay_quantity: Optional[StrictInt] = Field(default=None, description="A delays quantity number of adjustments to the term of the patent based upon USPTO delays included in the PTA determination that is mailed as part of the ISSUE NOTIFICATION LETTER.", alias="aDelayQuantity")
    adjustment_total_quantity: Optional[StrictInt] = Field(default=None, description="Patent term adjustment total quantity number that is a summation of NONOVERLAPPING USPTO DELAYS (+/- PTO MANUAL ADJUSTMENTS) - APPLICANT DELAYS.", alias="adjustmentTotalQuantity")
    applicant_day_delay_quantity: Optional[StrictInt] = Field(default=None, description="Patent term adjustment applicant delays quantity number of the patent term due to the Applicant's failure to engage in reasonable efforts to conclude prosecution of the application for the cumulative period in excess of three", alias="applicantDayDelayQuantity")
    b_delay_quantity: Optional[StrictInt] = Field(default=None, description="B delays quantity number of adjustments to the term of the patent based upon the patent failing to issue within three years of the actual filing date of the application at the time that the issue notification letter is generated and an issue date has been established.", alias="bDelayQuantity")
    c_delay_quantity: Optional[StrictInt] = Field(default=None, description="C delays quantity number of adjustments to the term of the patent based upon USPTO delays caused by interference proceedings, secrecy orders, and successful appellate reviews.", alias="cDelayQuantity")
    non_overlapping_day_quantity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Patent term adjustment non overlapping days quantity number of overall summation of the USPTO delays minus any overlapping days.", alias="nonOverlappingDayQuantity")
    overlapping_day_quantity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Patent term adjustment overlapping days quantity number that reflects the calculation of overlapping delays consistent with the federal circuit's interpretation.", alias="overlappingDayQuantity")
    patent_term_adjustment_history_data_bag: Optional[List[PatentTermAdjustmentPatentTermAdjustmentHistoryDataBagInner]] = Field(default=None, alias="patentTermAdjustmentHistoryDataBag")
    __properties: ClassVar[List[str]] = ["aDelayQuantity", "adjustmentTotalQuantity", "applicantDayDelayQuantity", "bDelayQuantity", "cDelayQuantity", "nonOverlappingDayQuantity", "overlappingDayQuantity", "patentTermAdjustmentHistoryDataBag"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatentTermAdjustment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in patent_term_adjustment_history_data_bag (list)
        _items = []
        if self.patent_term_adjustment_history_data_bag:
            for _item_patent_term_adjustment_history_data_bag in self.patent_term_adjustment_history_data_bag:
                if _item_patent_term_adjustment_history_data_bag:
                    _items.append(_item_patent_term_adjustment_history_data_bag.to_dict())
            _dict['patentTermAdjustmentHistoryDataBag'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatentTermAdjustment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "aDelayQuantity": obj.get("aDelayQuantity"),
            "adjustmentTotalQuantity": obj.get("adjustmentTotalQuantity"),
            "applicantDayDelayQuantity": obj.get("applicantDayDelayQuantity"),
            "bDelayQuantity": obj.get("bDelayQuantity"),
            "cDelayQuantity": obj.get("cDelayQuantity"),
            "nonOverlappingDayQuantity": obj.get("nonOverlappingDayQuantity"),
            "overlappingDayQuantity": obj.get("overlappingDayQuantity"),
            "patentTermAdjustmentHistoryDataBag": [PatentTermAdjustmentPatentTermAdjustmentHistoryDataBagInner.from_dict(_item) for _item in obj["patentTermAdjustmentHistoryDataBag"]] if obj.get("patentTermAdjustmentHistoryDataBag") is not None else None
        })
        return _obj


